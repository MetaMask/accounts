<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MetaMask WebView</title>
</head>
<body>
  <div id="root"></div>
  <script>/*! For license information please see bundle.js.LICENSE.txt */
(()=>{"use strict";var t={d:(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function n(t,...e){if(!((r=t)instanceof Uint8Array||null!=r&&"object"==typeof r&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");var r;if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function i(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}t.r(e),t.d(e,{DO:()=>dt,OG:()=>It,My:()=>wt,Ph:()=>Et,lX:()=>mt,Id:()=>Bt,fg:()=>Kt,qj:()=>At,aT:()=>bt,aY:()=>ut,lq:()=>xt,z:()=>vt,Q5:()=>Rt});const o="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,s=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),a=(t,e)=>t<<32-e|t>>>e,h=(t,e)=>t<<e|t>>>32-e>>>0;new Uint8Array(new Uint32Array([287454020]).buffer)[0];const f=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function c(t){return t>=48&&t<=57?t-48:t>=65&&t<=70?t-55:t>=97&&t<=102?t-87:void 0}function u(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function d(t){return"string"==typeof t&&(t=u(t)),n(t),t}function l(...t){let e=0;for(let r=0;r<t.length;r++){const i=t[r];n(i),e+=i.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}class w{clone(){return this._cloneInto()}}function p(t){const e=e=>t().update(d(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function g(t=32){if(o&&"function"==typeof o.getRandomValues)return o.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}class y extends w{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(t.outputLen),r(t.blockLen)}(t);const n=d(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?t.create().update(n).digest():n);for(let t=0;t<o.length;t++)o[t]^=54;this.iHash.update(o),this.oHash=t.create();for(let t=0;t<o.length;t++)o[t]^=106;this.oHash.update(o),o.fill(0)}update(t){return i(this),this.iHash.update(t),this}digestInto(t){i(this),n(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:i,blockLen:o,outputLen:s}=this;return t.finished=n,t.destroyed=i,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const b=(t,e,r)=>new y(t,e).update(r).digest();b.create=(t,e)=>new y(t,e);const E=(t,e,r)=>t&e^~t&r,m=(t,e,r)=>t&e^t&r^e&r;class x extends w{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=s(this.buffer)}update(t){i(this);const{view:e,buffer:r,blockLen:n}=this,o=(t=d(t)).length;for(let i=0;i<o;){const a=Math.min(n-this.pos,o-i);if(a===n){const e=s(t);for(;n<=o-i;i+=n)this.process(e,i);continue}r.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===n&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){i(this),function(t,e){n(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:a}=this;let{pos:h}=this;e[h++]=128,this.buffer.subarray(h).fill(0),this.padOffset>o-h&&(this.process(r,0),h=0);for(let t=h;t<o;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),a=Number(r&o),h=n?4:0,f=n?0:4;t.setUint32(e+h,s,n),t.setUint32(e+f,a,n)}(r,o-8,BigInt(8*this.length),a),this.process(r,0);const f=s(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,d=this.get();if(u>d.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<u;t++)f.setUint32(4*t,d[t],a)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:i,destroyed:o,pos:s}=this;return t.length=n,t.pos=s,t.finished=i,t.destroyed=o,n%e&&t.buffer.set(r),t}}const v=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),A=new Uint8Array(new Array(16).fill(0).map((t,e)=>e));let B=[A],I=[A.map(t=>(9*t+5)%16)];for(let t=0;t<4;t++)for(let e of[B,I])e.push(e[t].map(t=>v[t]));const S=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>new Uint8Array(t)),U=B.map((t,e)=>t.map(t=>S[e][t])),K=I.map((t,e)=>t.map(t=>S[e][t])),O=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),R=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);function N(t,e,r,n){return 0===t?e^r^n:1===t?e&r|~e&n:2===t?(e|~r)^n:3===t?e&n|r&~n:e^(r|~n)}const C=new Uint32Array(16);class H extends x{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:r,h3:n,h4:i}=this;return[t,e,r,n,i]}set(t,e,r,n,i){this.h0=0|t,this.h1=0|e,this.h2=0|r,this.h3=0|n,this.h4=0|i}process(t,e){for(let r=0;r<16;r++,e+=4)C[r]=t.getUint32(e,!0);let r=0|this.h0,n=r,i=0|this.h1,o=i,s=0|this.h2,a=s,f=0|this.h3,c=f,u=0|this.h4,d=u;for(let t=0;t<5;t++){const e=4-t,l=O[t],w=R[t],p=B[t],g=I[t],y=U[t],b=K[t];for(let e=0;e<16;e++){const n=h(r+N(t,i,s,f)+C[p[e]]+l,y[e])+u|0;r=u,u=f,f=0|h(s,10),s=i,i=n}for(let t=0;t<16;t++){const r=h(n+N(e,o,a,c)+C[g[t]]+w,b[t])+d|0;n=d,d=c,c=0|h(a,10),a=o,o=r}}this.set(this.h1+s+c|0,this.h2+f+d|0,this.h3+u+n|0,this.h4+r+o|0,this.h0+i+a|0)}roundClean(){C.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const L=p(()=>new H),$=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),F=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),q=new Uint32Array(64);class k extends x{constructor(){super(64,32,8,!1),this.A=0|F[0],this.B=0|F[1],this.C=0|F[2],this.D=0|F[3],this.E=0|F[4],this.F=0|F[5],this.G=0|F[6],this.H=0|F[7]}get(){const{A:t,B:e,C:r,D:n,E:i,F:o,G:s,H:a}=this;return[t,e,r,n,i,o,s,a]}set(t,e,r,n,i,o,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)q[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=q[t-15],r=q[t-2],n=a(e,7)^a(e,18)^e>>>3,i=a(r,17)^a(r,19)^r>>>10;q[t]=i+q[t-7]+n+q[t-16]|0}let{A:r,B:n,C:i,D:o,E:s,F:h,G:f,H:c}=this;for(let t=0;t<64;t++){const e=c+(a(s,6)^a(s,11)^a(s,25))+E(s,h,f)+$[t]+q[t]|0,u=(a(r,2)^a(r,13)^a(r,22))+m(r,n,i)|0;c=f,f=h,h=s,s=o+e|0,o=i,i=n,n=r,r=e+u|0}r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,o=o+this.D|0,s=s+this.E|0,h=h+this.F|0,f=f+this.G|0,c=c+this.H|0,this.set(r,n,i,o,s,h,f,c)}roundClean(){q.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const P=p(()=>new k),D=BigInt(2**32-1),M=BigInt(32);function T(t,e=!1){return e?{h:Number(t&D),l:Number(t>>M&D)}:{h:0|Number(t>>M&D),l:0|Number(t&D)}}const z=function(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let i=0;i<t.length;i++){const{h:o,l:s}=T(t[i],e);[r[i],n[i]]=[o,s]}return[r,n]},j=(t,e,r)=>t>>>r,V=(t,e,r)=>t<<32-r|e>>>r,_=(t,e,r)=>t>>>r|e<<32-r,Z=(t,e,r)=>t<<32-r|e>>>r,G=(t,e,r)=>t<<64-r|e>>>r-32,W=(t,e,r)=>t>>>r-32|e<<64-r,Y=function(t,e,r,n){const i=(e>>>0)+(n>>>0);return{h:t+r+(i/2**32|0)|0,l:0|i}},J=(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),Q=(t,e,r,n)=>e+r+n+(t/2**32|0)|0,X=(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),tt=(t,e,r,n,i)=>e+r+n+i+(t/2**32|0)|0,et=(t,e,r,n,i,o)=>e+r+n+i+o+(t/2**32|0)|0,rt=(t,e,r,n,i)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(i>>>0),[nt,it]=(()=>z(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),ot=new Uint32Array(80),st=new Uint32Array(80);class at extends x{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:n,Ch:i,Cl:o,Dh:s,Dl:a,Eh:h,El:f,Fh:c,Fl:u,Gh:d,Gl:l,Hh:w,Hl:p}=this;return[t,e,r,n,i,o,s,a,h,f,c,u,d,l,w,p]}set(t,e,r,n,i,o,s,a,h,f,c,u,d,l,w,p){this.Ah=0|t,this.Al=0|e,this.Bh=0|r,this.Bl=0|n,this.Ch=0|i,this.Cl=0|o,this.Dh=0|s,this.Dl=0|a,this.Eh=0|h,this.El=0|f,this.Fh=0|c,this.Fl=0|u,this.Gh=0|d,this.Gl=0|l,this.Hh=0|w,this.Hl=0|p}process(t,e){for(let r=0;r<16;r++,e+=4)ot[r]=t.getUint32(e),st[r]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|ot[t-15],r=0|st[t-15],n=_(e,r,1)^_(e,r,8)^j(e,r,7),i=Z(e,r,1)^Z(e,r,8)^V(e,r,7),o=0|ot[t-2],s=0|st[t-2],a=_(o,s,19)^G(o,s,61)^j(o,s,6),h=Z(o,s,19)^W(o,s,61)^V(o,s,6),f=X(i,h,st[t-7],st[t-16]),c=tt(f,n,a,ot[t-7],ot[t-16]);ot[t]=0|c,st[t]=0|f}let{Ah:r,Al:n,Bh:i,Bl:o,Ch:s,Cl:a,Dh:h,Dl:f,Eh:c,El:u,Fh:d,Fl:l,Gh:w,Gl:p,Hh:g,Hl:y}=this;for(let t=0;t<80;t++){const e=_(c,u,14)^_(c,u,18)^G(c,u,41),b=Z(c,u,14)^Z(c,u,18)^W(c,u,41),E=c&d^~c&w,m=rt(y,b,u&l^~u&p,it[t],st[t]),x=et(m,g,e,E,nt[t],ot[t]),v=0|m,A=_(r,n,28)^G(r,n,34)^G(r,n,39),B=Z(r,n,28)^W(r,n,34)^W(r,n,39),I=r&i^r&s^i&s,S=n&o^n&a^o&a;g=0|w,y=0|p,w=0|d,p=0|l,d=0|c,l=0|u,({h:c,l:u}=Y(0|h,0|f,0|x,0|v)),h=0|s,f=0|a,s=0|i,a=0|o,i=0|r,o=0|n;const U=J(v,B,S);r=Q(U,x,A,I),n=0|U}({h:r,l:n}=Y(0|this.Ah,0|this.Al,0|r,0|n)),({h:i,l:o}=Y(0|this.Bh,0|this.Bl,0|i,0|o)),({h:s,l:a}=Y(0|this.Ch,0|this.Cl,0|s,0|a)),({h,l:f}=Y(0|this.Dh,0|this.Dl,0|h,0|f)),({h:c,l:u}=Y(0|this.Eh,0|this.El,0|c,0|u)),({h:d,l}=Y(0|this.Fh,0|this.Fl,0|d,0|l)),({h:w,l:p}=Y(0|this.Gh,0|this.Gl,0|w,0|p)),({h:g,l:y}=Y(0|this.Hh,0|this.Hl,0|g,0|y)),this.set(r,n,i,o,s,a,h,f,c,u,d,l,w,p,g,y)}roundClean(){ot.fill(0),st.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const ht=p(()=>new at),ft=BigInt(1),ct=BigInt(2);function ut(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function dt(t){if(!ut(t))throw new Error("Uint8Array expected")}const lt=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function wt(t){dt(t);let e="";for(let r=0;r<t.length;r++)e+=lt[t[r]];return e}function pt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const gt={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function yt(t){return t>=gt._0&&t<=gt._9?t-gt._0:t>=gt._A&&t<=gt._F?t-(gt._A-10):t>=gt._a&&t<=gt._f?t-(gt._a-10):void 0}function bt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,r=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,i=0;e<r;e++,i+=2){const r=yt(t.charCodeAt(i)),o=yt(t.charCodeAt(i+1));if(void 0===r||void 0===o){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}n[e]=16*r+o}return n}function Et(t){return pt(wt(t))}function mt(t){return dt(t),pt(wt(Uint8Array.from(t).reverse()))}function xt(t,e){return bt(t.toString(16).padStart(2*e,"0"))}function vt(t,e){return xt(t,e).reverse()}function At(t,e,r){let n;if("string"==typeof e)try{n=bt(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!ut(e))throw new Error(`${t} must be hex string or Uint8Array`);n=Uint8Array.from(e)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(`${t} expected ${r} bytes, got ${i}`);return n}function Bt(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];dt(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}const It=t=>(ct<<BigInt(t-1))-ft,St=t=>new Uint8Array(t),Ut=t=>Uint8Array.from(t);function Kt(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=St(t),i=St(t),o=0;const s=()=>{n.fill(1),i.fill(0),o=0},a=(...t)=>r(i,n,...t),h=(t=St())=>{i=a(Ut([0]),t),n=a(),0!==t.length&&(i=a(Ut([1]),t),n=a())},f=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=a();const e=n.slice();r.push(e),t+=n.length}return Bt(...r)};return(t,e)=>{let r;for(s(),h(t);!(r=e(f()));)h();return s(),r}}const Ot={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||ut(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function Rt(t,e,r={}){const n=(e,r,n)=>{const i=Ot[r];if("function"!=typeof i)throw new Error(`Invalid validator "${r}", expected function`);const o=t[e];if(!(n&&void 0===o||i(o,t)))throw new Error(`Invalid param ${String(e)}=${o} (${typeof o}), expected ${r}`)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}const Nt=BigInt(0),Ct=BigInt(1),Ht=BigInt(2),Lt=BigInt(3),$t=BigInt(4),Ft=BigInt(5),qt=BigInt(8);function kt(t,e){const r=t%e;return r>=Nt?r:e+r}function Pt(t,e,r){if(r<=Nt||e<Nt)throw new Error("Expected power/modulo > 0");if(r===Ct)return Nt;let n=Ct;for(;e>Nt;)e&Ct&&(n=n*t%r),t=t*t%r,e>>=Ct;return n}function Dt(t,e,r){let n=t;for(;e-- >Nt;)n*=n,n%=r;return n}function Mt(t,e){if(t===Nt||e<=Nt)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=kt(t,e),n=e,i=Nt,o=Ct,s=Ct,a=Nt;for(;r!==Nt;){const t=n/r,e=n%r,h=i-s*t,f=o-a*t;n=r,r=e,i=s,o=a,s=h,a=f}if(n!==Ct)throw new Error("invert: does not exist");return kt(i,e)}BigInt(9),BigInt(16);const Tt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function zt(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function jt(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Vt(t){const e=jt(t);return e+Math.ceil(e/2)}const _t=BigInt(0),Zt=BigInt(1);function Gt(t){return Rt(t.Fp,Tt.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),Rt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...zt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}const{Ph:Wt,aT:Yt}=e,Jt={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=Jt;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const r=t[1],n=t.subarray(2,r+2);if(!r||n.length!==r)throw new e("Invalid signature integer: wrong length");if(128&n[0])throw new e("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Wt(n),l:t.subarray(r+2)}},toSig(t){const{Err:e}=Jt,r="string"==typeof t?Yt(t):t;dt(r);let n=r.length;if(n<2||48!=r[0])throw new e("Invalid signature tag");if(r[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:i,l:o}=Jt._parseInt(r.subarray(2)),{d:s,l:a}=Jt._parseInt(o);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,r=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},n=e(r(t.s)),i=e(r(t.r)),o=n.length/2,s=i.length/2,a=r(o),h=r(s);return`30${r(s+o+4)}02${h}${i}02${a}${n}`}},Qt=BigInt(0),Xt=BigInt(1),te=(BigInt(2),BigInt(3));function ee(t){const e=function(t){const e=Gt(t);return Rt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n}=e,i=r.BYTES+1,o=2*r.BYTES+1;function s(t){return kt(t,n)}function a(t){return Mt(t,n)}const{ProjectivePoint:h,normPrivateKeyToScalar:f,weierstrassEquation:c,isWithinCurveOrder:u}=function(t){const e=function(t){const e=Gt(t);Rt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=e;if(r){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,n=e.toBytes||((t,e,n)=>{const i=e.toAffine();return Bt(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),i=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function o(t){const{a:n,b:i}=e,o=r.sqr(t),s=r.mul(o,t);return r.add(r.add(s,r.mul(t,n)),i)}if(!r.eql(r.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function s(t){return"bigint"==typeof t&&Qt<t&&t<e.n}function a(t){if(!s(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function h(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:o}=e;if(r&&"bigint"!=typeof t){if(ut(t)&&(t=wt(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*n,"0")}let s;try{s="bigint"==typeof t?t:Et(At("private key",t,n))}catch(e){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)}return i&&(s=kt(s,o)),a(s),s}const f=new Map;function c(t){if(!(t instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof u)throw new Error("projective point not allowed");const i=t=>r.eql(t,r.ZERO);return i(e)&&i(n)?u.ZERO:new u(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map(t=>t.pz));return t.map((t,r)=>t.toAffine(e[r])).map(u.fromAffine)}static fromHex(t){const e=u.fromAffine(i(At("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return u.BASE.multiply(h(t))}_setWindowSize(t){this._WINDOW_SIZE=t,f.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:n}=this.toAffine();if(!r.isValid(t)||!r.isValid(n))throw new Error("bad point: x or y not FE");const i=r.sqr(n),s=o(t);if(!r.eql(i,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){c(t);const{px:e,py:n,pz:i}=this,{px:o,py:s,pz:a}=t,h=r.eql(r.mul(e,a),r.mul(o,i)),f=r.eql(r.mul(n,a),r.mul(s,i));return h&&f}negate(){return new u(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,i=r.mul(n,te),{px:o,py:s,pz:a}=this;let h=r.ZERO,f=r.ZERO,c=r.ZERO,d=r.mul(o,o),l=r.mul(s,s),w=r.mul(a,a),p=r.mul(o,s);return p=r.add(p,p),c=r.mul(o,a),c=r.add(c,c),h=r.mul(t,c),f=r.mul(i,w),f=r.add(h,f),h=r.sub(l,f),f=r.add(l,f),f=r.mul(h,f),h=r.mul(p,h),c=r.mul(i,c),w=r.mul(t,w),p=r.sub(d,w),p=r.mul(t,p),p=r.add(p,c),c=r.add(d,d),d=r.add(c,d),d=r.add(d,w),d=r.mul(d,p),f=r.add(f,d),w=r.mul(s,a),w=r.add(w,w),d=r.mul(w,p),h=r.sub(h,d),c=r.mul(w,l),c=r.add(c,c),c=r.add(c,c),new u(h,f,c)}add(t){c(t);const{px:n,py:i,pz:o}=this,{px:s,py:a,pz:h}=t;let f=r.ZERO,d=r.ZERO,l=r.ZERO;const w=e.a,p=r.mul(e.b,te);let g=r.mul(n,s),y=r.mul(i,a),b=r.mul(o,h),E=r.add(n,i),m=r.add(s,a);E=r.mul(E,m),m=r.add(g,y),E=r.sub(E,m),m=r.add(n,o);let x=r.add(s,h);return m=r.mul(m,x),x=r.add(g,b),m=r.sub(m,x),x=r.add(i,o),f=r.add(a,h),x=r.mul(x,f),f=r.add(y,b),x=r.sub(x,f),l=r.mul(w,m),f=r.mul(p,b),l=r.add(f,l),f=r.sub(y,l),l=r.add(y,l),d=r.mul(f,l),y=r.add(g,g),y=r.add(y,g),b=r.mul(w,b),m=r.mul(p,m),y=r.add(y,b),b=r.sub(g,b),b=r.mul(w,b),m=r.add(m,b),g=r.mul(y,m),d=r.add(d,g),g=r.mul(x,m),f=r.mul(E,f),f=r.sub(f,g),g=r.mul(E,y),l=r.mul(x,l),l=r.add(l,g),new u(f,d,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(u.ZERO)}wNAF(t){return l.wNAFCached(this,f,t,t=>{const e=r.invertBatch(t.map(t=>t.pz));return t.map((t,r)=>t.toAffine(e[r])).map(u.fromAffine)})}multiplyUnsafe(t){const n=u.ZERO;if(t===Qt)return n;if(a(t),t===Xt)return this;const{endo:i}=e;if(!i)return l.unsafeLadder(this,t);let{k1neg:o,k1:s,k2neg:h,k2:f}=i.splitScalar(t),c=n,d=n,w=this;for(;s>Qt||f>Qt;)s&Xt&&(c=c.add(w)),f&Xt&&(d=d.add(w)),w=w.double(),s>>=Xt,f>>=Xt;return o&&(c=c.negate()),h&&(d=d.negate()),d=new u(r.mul(d.px,i.beta),d.py,d.pz),c.add(d)}multiply(t){a(t);let n,i,o=t;const{endo:s}=e;if(s){const{k1neg:t,k1:e,k2neg:a,k2:h}=s.splitScalar(o);let{p:f,f:c}=this.wNAF(e),{p:d,f:w}=this.wNAF(h);f=l.constTimeNegate(t,f),d=l.constTimeNegate(a,d),d=new u(r.mul(d.px,s.beta),d.py,d.pz),n=f.add(d),i=c.add(w)}else{const{p:t,f:e}=this.wNAF(o);n=t,i=e}return u.normalizeZ([n,i])[0]}multiplyAndAddUnsafe(t,e,r){const n=u.BASE,i=(t,e)=>e!==Qt&&e!==Xt&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),o=i(this,e).add(i(t,r));return o.is0()?void 0:o}toAffine(t){const{px:e,py:n,pz:i}=this,o=this.is0();null==t&&(t=o?r.ONE:r.inv(i));const s=r.mul(e,t),a=r.mul(n,t),h=r.mul(i,t);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(h,r.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Xt)return!0;if(r)return r(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Xt?this:r?r(u,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),n(u,this,t)}toHex(t=!0){return wt(this.toRawBytes(t))}}u.BASE=new u(e.Gx,e.Gy,r.ONE),u.ZERO=new u(r.ZERO,r.ONE,r.ZERO);const d=e.nBitLength,l=function(t,e){const r=(t,e)=>{const r=e.negate();return t?r:e},n=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:r,unsafeLadder(e,r){let n=t.ZERO,i=e;for(;r>_t;)r&Zt&&(n=n.add(i)),i=i.double(),r>>=Zt;return n},precomputeWindow(t,e){const{windows:r,windowSize:i}=n(e),o=[];let s=t,a=s;for(let t=0;t<r;t++){a=s,o.push(a);for(let t=1;t<i;t++)a=a.add(s),o.push(a);s=a.double()}return o},wNAF(e,i,o){const{windows:s,windowSize:a}=n(e);let h=t.ZERO,f=t.BASE;const c=BigInt(2**e-1),u=2**e,d=BigInt(e);for(let t=0;t<s;t++){const e=t*a;let n=Number(o&c);o>>=d,n>a&&(n-=u,o+=Zt);const s=e,l=e+Math.abs(n)-1,w=t%2!=0,p=n<0;0===n?f=f.add(r(w,i[s])):h=h.add(r(p,i[l]))}return{p:h,f}},wNAFCached(t,e,r,n){const i=t._WINDOW_SIZE||1;let o=e.get(t);return o||(o=this.precomputeWindow(t,i),1!==i&&e.set(t,n(o))),this.wNAF(i,o,r)}}}(u,e.endo?Math.ceil(d/2):d);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:h,weierstrassEquation:o,isWithinCurveOrder:s}}({...e,toBytes(t,e,n){const i=e.toAffine(),o=r.toBytes(i.x),s=Bt;return n?s(Uint8Array.from([e.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(i.y))},fromBytes(t){const e=t.length,n=t[0],s=t.subarray(1);if(e!==i||2!==n&&3!==n){if(e===o&&4===n)return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))};throw new Error(`Point of length ${e} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}{const t=Et(s);if(!(Qt<(a=t)&&a<r.ORDER))throw new Error("Point is not on curve");const e=c(t);let i;try{i=r.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return!(1&~n)!=((i&Xt)===Xt)&&(i=r.neg(i)),{x:t,y:i}}var a}}),d=t=>wt(xt(t,e.nByteLength));function l(t){return t>n>>Xt}const w=(t,e,r)=>Et(t.slice(e,r));class p{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=At("compactSignature",t,2*r),new p(w(t,0,r),w(t,r,2*r))}static fromDER(t){const{r:e,s:r}=Jt.toSig(At("DER",t));return new p(e,r)}assertValidity(){if(!u(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!u(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new p(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:i,recovery:o}=this,f=E(At("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const c=2===o||3===o?n+e.n:n;if(c>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const u=1&o?"03":"02",l=h.fromHex(u+d(c)),w=a(c),p=s(-f*w),g=s(i*w),y=h.BASE.multiplyAndAddUnsafe(l,p,g);if(!y)throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return l(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return bt(this.toDERHex())}toDERHex(){return Jt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return bt(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const g={isValidPrivateKey(t){try{return f(t),!0}catch(t){return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{const t=Vt(e.n);return function(t,e,r=!1){const n=t.length,i=jt(e),o=Vt(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const s=kt(r?Et(t):mt(t),e-Ct)+Ct;return r?vt(s,i):xt(s,i)}(e.randomBytes(t),e.n)},precompute:(t=8,e=h.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function y(t){const e=ut(t),r="string"==typeof t,n=(e||r)&&t.length;return e?n===i||n===o:r?n===2*i||n===2*o:t instanceof h}const b=e.bits2int||function(t){const r=Et(t),n=8*t.length-e.nBitLength;return n>0?r>>BigInt(n):r},E=e.bits2int_modN||function(t){return s(b(t))},m=It(e.nBitLength);function x(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(Qt<=t&&t<m))throw new Error(`bigint expected < 2^${e.nBitLength}`);return xt(t,e.nByteLength)}const v={lowS:e.lowS,prehash:!1},A={lowS:e.lowS,prehash:!1};return h.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return h.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(y(t))throw new Error("first arg must be private key");if(!y(e))throw new Error("second arg must be public key");return h.fromHex(e).multiply(f(t)).toRawBytes(r)},sign:function(t,n,i=v){const{seed:o,k2sig:c}=function(t,n,i=v){if(["recovered","canonical"].some(t=>t in i))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:c}=e;let{lowS:d,prehash:w,extraEntropy:g}=i;null==d&&(d=!0),t=At("msgHash",t),w&&(t=At("prehashed msgHash",o(t)));const y=E(t),m=f(n),A=[x(m),x(y)];if(null!=g&&!1!==g){const t=!0===g?c(r.BYTES):g;A.push(At("extraEntropy",t))}const B=Bt(...A),I=y;return{seed:B,k2sig:function(t){const e=b(t);if(!u(e))return;const r=a(e),n=h.BASE.multiply(e).toAffine(),i=s(n.x);if(i===Qt)return;const o=s(r*s(I+i*m));if(o===Qt)return;let f=(n.x===i?0:2)|Number(n.y&Xt),c=o;return d&&l(o)&&(c=function(t){return l(t)?s(-t):t}(o),f^=1),new p(i,c,f)}}}(t,n,i),d=e;return Kt(d.hash.outputLen,d.nByteLength,d.hmac)(o,c)},verify:function(t,r,n,i=A){const o=t;if(r=At("msgHash",r),n=At("publicKey",n),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:f,prehash:c}=i;let u,d;try{if("string"==typeof o||ut(o))try{u=p.fromDER(o)}catch(t){if(!(t instanceof Jt.Err))throw t;u=p.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:t,s:e}=o;u=new p(t,e)}}d=h.fromHex(n)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(f&&u.hasHighS())return!1;c&&(r=e.hash(r));const{r:l,s:w}=u,g=E(r),y=a(w),b=s(g*y),m=s(l*y),x=h.BASE.multiplyAndAddUnsafe(d,b,m)?.toAffine();return!!x&&s(x.x)===l},ProjectivePoint:h,Signature:p,utils:g}}function re(t){return{hash:t,hmac:(e,...r)=>b(t,e,l(...r)),randomBytes:g}}BigInt(4);const ne=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ie=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),oe=BigInt(1),se=BigInt(2),ae=(t,e)=>(t+e/se)/e;const he=function(t,e,r=!1,n={}){if(t<=Nt)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:i,nByteLength:o}=zt(t,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=function(t){if(t%$t===Lt){const e=(t+Ct)/$t;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}if(t%qt===Ft){const e=(t-Ft)/qt;return function(t,r){const n=t.mul(r,Ht),i=t.pow(n,e),o=t.mul(r,i),s=t.mul(t.mul(o,Ht),i),a=t.mul(o,t.sub(s,t.ONE));if(!t.eql(t.sqr(a),r))throw new Error("Cannot find square root");return a}}return function(t){const e=(t-Ct)/Ht;let r,n,i;for(r=t-Ct,n=0;r%Ht===Nt;r/=Ht,n++);for(i=Ht;i<t&&Pt(i,e,t)!==t-Ct;i++);if(1===n){const e=(t+Ct)/$t;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}const o=(r+Ct)/Ht;return function(t,s){if(t.pow(s,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let a=n,h=t.pow(t.mul(t.ONE,i),r),f=t.pow(s,o),c=t.pow(s,r);for(;!t.eql(c,t.ONE);){if(t.eql(c,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(c);e<a&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(h,Ct<<BigInt(a-e-1));h=t.sqr(r),f=t.mul(f,r),c=t.mul(c,h),a=e}return f}}(t)}(t),a=Object.freeze({ORDER:t,BITS:i,BYTES:o,MASK:It(i),ZERO:Nt,ONE:Ct,create:e=>kt(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return Nt<=e&&e<t},is0:t=>t===Nt,isOdd:t=>(t&Ct)===Ct,neg:e=>kt(-e,t),eql:(t,e)=>t===e,sqr:e=>kt(e*e,t),add:(e,r)=>kt(e+r,t),sub:(e,r)=>kt(e-r,t),mul:(e,r)=>kt(e*r,t),pow:(t,e)=>function(t,e,r){if(r<Nt)throw new Error("Expected power > 0");if(r===Nt)return t.ONE;if(r===Ct)return e;let n=t.ONE,i=e;for(;r>Nt;)r&Ct&&(n=t.mul(n,i)),i=t.sqr(i),r>>=Ct;return n}(a,t,e),div:(e,r)=>kt(e*Mt(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>Mt(e,t),sqrt:n.sqrt||(t=>s(a,t)),invertBatch:t=>function(t,e){const r=new Array(e.length),n=e.reduce((e,n,i)=>t.is0(n)?e:(r[i]=e,t.mul(e,n)),t.ONE),i=t.inv(n);return e.reduceRight((e,n,i)=>t.is0(n)?e:(r[i]=t.mul(e,r[i]),t.mul(e,n)),i),r}(a,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?vt(t,o):xt(t,o),fromBytes:t=>{if(t.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${t.length}`);return r?mt(t):Et(t)}});return Object.freeze(a)}(ne,void 0,void 0,{sqrt:function(t){const e=ne,r=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),h=BigInt(88),f=t*t*t%e,c=f*f*t%e,u=Dt(c,r,e)*c%e,d=Dt(u,r,e)*c%e,l=Dt(d,se,e)*f%e,w=Dt(l,i,e)*l%e,p=Dt(w,o,e)*w%e,g=Dt(p,a,e)*p%e,y=Dt(g,h,e)*g%e,b=Dt(y,a,e)*p%e,E=Dt(b,r,e)*c%e,m=Dt(E,s,e)*w%e,x=Dt(m,n,e)*f%e,v=Dt(x,se,e);if(!he.eql(he.sqr(v),t))throw new Error("Cannot find square root");return v}}),fe=function(t,e){const r=e=>ee({...t,...re(e)});return Object.freeze({...r(e),create:r})}({a:BigInt(0),b:BigInt(7),Fp:he,n:ie,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=ie,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-oe*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,s=BigInt("0x100000000000000000000000000000000"),a=ae(o*t,e),h=ae(-n*t,e);let f=kt(t-a*r-h*i,e),c=kt(-a*n-h*o,e);const u=f>s,d=c>s;if(u&&(f=e-f),d&&(c=e-c),f>s||c>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:f,k2neg:d,k2:c}}}},P);function ce(t){if(!Number.isSafeInteger(t))throw new Error(`Wrong integer: ${t}`)}function ue(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function de(...t){const e=t=>t,r=(t,e)=>r=>t(e(r));return{encode:t.map(t=>t.encode).reduceRight(r,e),decode:t.map(t=>t.decode).reduce(r,e)}}function le(t){return{encode:e=>{if(!Array.isArray(e)||e.length&&"number"!=typeof e[0])throw new Error("alphabet.encode input should be an array of numbers");return e.map(e=>{if(ce(e),e<0||e>=t.length)throw new Error(`Digit index outside alphabet: ${e} (alphabet: ${t.length})`);return t[e]})},decode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("alphabet.decode input should be array of strings");return e.map(e=>{if("string"!=typeof e)throw new Error(`alphabet.decode: not string element=${e}`);const r=t.indexOf(e);if(-1===r)throw new Error(`Unknown letter: "${e}". Allowed: ${t}`);return r})}}}function we(t=""){if("string"!=typeof t)throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("join.encode input should be array of strings");for(let t of e)if("string"!=typeof t)throw new Error(`join.encode: non-string input=${t}`);return e.join(t)},decode:e=>{if("string"!=typeof e)throw new Error("join.decode input should be string");return e.split(t)}}}function pe(t,e="="){if(ce(t),"string"!=typeof e)throw new Error("padding chr should be string");return{encode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let t of r)if("string"!=typeof t)throw new Error(`padding.encode: non-string input=${t}`);for(;r.length*t%8;)r.push(e);return r},decode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let t of r)if("string"!=typeof t)throw new Error(`padding.decode: non-string input=${t}`);let n=r.length;if(n*t%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;n>0&&r[n-1]===e;n--)if(!((n-1)*t%8))throw new Error("Invalid padding: string has too much padding");return r.slice(0,n)}}}function ge(t){if("function"!=typeof t)throw new Error("normalize fn should be function");return{encode:t=>t,decode:e=>t(e)}}function ye(t,e,r){if(e<2)throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);if(!Array.isArray(t))throw new Error("convertRadix: data should be array");if(!t.length)return[];let n=0;const i=[],o=Array.from(t);for(o.forEach(t=>{if(ce(t),t<0||t>=e)throw new Error(`Wrong integer: ${t}`)});;){let t=0,s=!0;for(let i=n;i<o.length;i++){const a=o[i],h=e*t+a;if(!Number.isSafeInteger(h)||e*t/e!==t||h-a!==e*t)throw new Error("convertRadix: carry overflow");t=h%r;const f=Math.floor(h/r);if(o[i]=f,!Number.isSafeInteger(f)||f*r+t!==h)throw new Error("convertRadix: carry overflow");s&&(f?s=!1:n=i)}if(i.push(t),s)break}for(let e=0;e<t.length-1&&0===t[e];e++)i.push(0);return i.reverse()}BigInt(0),fe.ProjectivePoint;const be=(t,e)=>e?be(e,t%e):t,Ee=(t,e)=>t+(e-be(t,e));function me(t,e,r,n){if(!Array.isArray(t))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(Ee(e,r)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${Ee(e,r)}`);let i=0,o=0;const s=2**r-1,a=[];for(const n of t){if(ce(n),n>=2**e)throw new Error(`convertRadix2: invalid data word=${n} from=${e}`);if(i=i<<e|n,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=r;o-=r)a.push((i>>o-r&s)>>>0);i&=2**o-1}if(i=i<<r-o&s,!n&&o>=e)throw new Error("Excess padding");if(!n&&i)throw new Error(`Non-zero padding: ${i}`);return n&&o>0&&a.push(i>>>0),a}function xe(t,e=!1){if(ce(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(Ee(8,t)>32||Ee(t,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!ue(r))throw new Error("radix2.encode input should be Uint8Array");return me(Array.from(r),8,t,!e)},decode:r=>{if(!Array.isArray(r)||r.length&&"number"!=typeof r[0])throw new Error("radix2.decode input should be array of numbers");return Uint8Array.from(me(r,t,8,e))}}}xe(4),le("0123456789ABCDEF"),we(""),xe(5),le("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),pe(5),we(""),xe(5),le("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),we(""),xe(5),le("0123456789ABCDEFGHIJKLMNOPQRSTUV"),pe(5),we(""),xe(5),le("0123456789ABCDEFGHIJKLMNOPQRSTUV"),we(""),xe(5),le("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),we(""),ge(t=>t.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")),xe(6),le("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),pe(6),we(""),xe(6),le("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),we(""),xe(6),le("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),pe(6),we("");const ve=(xe(6),le("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),we(""),t=>{return de((ce(e=58),{encode:t=>{if(!ue(t))throw new Error("radix.encode input should be Uint8Array");return ye(Array.from(t),256,e)},decode:t=>{if(!Array.isArray(t)||t.length&&"number"!=typeof t[0])throw new Error("radix.decode input should be array of numbers");return Uint8Array.from(ye(t,e,256))}}),le(t),we(""));var e})("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");le("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),we("");const Ae=(xe(4),le("0123456789abcdef"),we(""),ge(t=>{if("string"!=typeof t||t.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);return t.toLowerCase()}),fe.ProjectivePoint),Be=(Ie=P,de(function(t,e){if(ce(t),"function"!=typeof e)throw new Error("checksum fn should be function");return{encode(r){if(!ue(r))throw new Error("checksum.encode: input should be Uint8Array");const n=e(r).slice(0,t),i=new Uint8Array(r.length+t);return i.set(r),i.set(n,r.length),i},decode(r){if(!ue(r))throw new Error("checksum.decode: input should be Uint8Array");const n=r.slice(0,-t),i=e(n).slice(0,t),o=r.slice(-t);for(let e=0;e<t;e++)if(i[e]!==o[e])throw new Error("Invalid checksum");return n}}}(4,t=>Ie(Ie(t))),ve));var Ie;function Se(t){return BigInt(`0x${function(t){n(t);let e="";for(let r=0;r<t.length;r++)e+=f[t[r]];return e}(t)}`)}const Ue=u("Bitcoin seed"),Ke={private:76066276,public:76067358},Oe=2147483648,Re=t=>{if(!Number.isSafeInteger(t)||t<0||t>2**32-1)throw new Error(`Invalid number=${t}. Should be from 0 to 2 ** 32 - 1`);const e=new Uint8Array(4);return s(e).setUint32(0,t,!1),e};class Ne{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return t=this.pubHash,s(t).getUint32(0,!1);var t}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const t=this.privateKey;if(!t)throw new Error("No private key");return Be.encode(this.serialize(this.versions.private,l(new Uint8Array([0]),t)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return Be.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(t,e=Ke){if(n(t),8*t.length<128||8*t.length>512)throw new Error(`HDKey: wrong seed length=${t.length}. Should be between 128 and 512 bits; 256 bits is advised)`);const r=b(ht,Ue,t);return new Ne({versions:e,chainCode:r.slice(32),privateKey:r.slice(0,32)})}static fromExtendedKey(t,e=Ke){const r=Be.decode(t),n=s(r),i=n.getUint32(0,!1),o={versions:e,depth:r[4],parentFingerprint:n.getUint32(5,!1),index:n.getUint32(9,!1),chainCode:r.slice(13,45)},a=r.slice(45),h=0===a[0];if(i!==e[h?"private":"public"])throw new Error("Version mismatch");return new Ne(h?{...o,privateKey:a.slice(1)}:{...o,publicKey:a})}static fromJSON(t){return Ne.fromExtendedKey(t.xpriv)}constructor(t){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!t||"object"!=typeof t)throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||Ke,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!fe.utils.isValidPrivateKey(t.privateKey))throw new Error("Invalid private key");this.privKey="bigint"==typeof t.privateKey?t.privateKey:Se(t.privateKey),this.privKeyBytes=function(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,r=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,i=0;e<r;e++,i+=2){const r=c(t.charCodeAt(i)),o=c(t.charCodeAt(i+1));if(void 0===r||void 0===o){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}n[e]=16*r+o}return n}(this.privKey.toString(16).padStart(64,"0")),this.pubKey=fe.getPublicKey(t.privateKey,!0)}else{if(!t.publicKey)throw new Error("HDKey: no public or private key provided");this.pubKey=Ae.fromHex(t.publicKey).toRawBytes(!0)}var e;this.pubHash=(e=this.pubKey,L(P(e)))}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const e=t.replace(/^[mM]'?\//,"").split("/");let r=this;for(const t of e){const e=/^(\d+)('?)$/.exec(t),n=e&&e[1];if(!e||3!==e.length||"string"!=typeof n)throw new Error(`Invalid child index: ${t}`);let i=+n;if(!Number.isSafeInteger(i)||i>=Oe)throw new Error("Invalid index");"'"===e[2]&&(i+=Oe),r=r.deriveChild(i)}return r}deriveChild(t){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let e=Re(t);if(t>=Oe){const t=this.privateKey;if(!t)throw new Error("Could not derive hardened child key");e=l(new Uint8Array([0]),t,e)}else e=l(this.pubKey,e);const r=b(ht,this.chainCode,e),n=Se(r.slice(0,32)),i=r.slice(32);if(!fe.utils.isValidPrivateKey(n))throw new Error("Tweak bigger than curve order");const o={versions:this.versions,chainCode:i,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t};try{if(this.privateKey){const t=kt(this.privKey+n,fe.CURVE.n);if(!fe.utils.isValidPrivateKey(t))throw new Error("The tweak was out of range or the resulted private key is invalid");o.privateKey=t}else{const t=Ae.fromHex(this.pubKey).add(Ae.fromPrivateKey(n));if(t.equals(Ae.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");o.publicKey=t.toRawBytes(!0)}return new Ne(o)}catch(e){return this.deriveChild(t+1)}}sign(t){if(!this.privateKey)throw new Error("No privateKey set!");return n(t,32),fe.sign(t,this.privKey).toCompactRawBytes()}verify(t,e){if(n(t,32),n(e,64),!this.publicKey)throw new Error("No publicKey set!");let r;try{r=fe.Signature.fromCompact(e)}catch(t){return!1}return fe.verify(r,t,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,e){if(!this.chainCode)throw new Error("No chainCode set");return n(e,33),l(Re(t),new Uint8Array([this.depth]),Re(this.parentFingerprint),Re(this.index),this.chainCode,e)}}const Ce=new Map;function He(){return Math.random().toString(36).substr(2,9)}const Le={fromMasterSeed:t=>{if(!t.seed)throw new Error("Missing seed parameter");const e=He(),r=Ne.fromMasterSeed(new Uint8Array(t.seed),t.versions);return Ce.set(e,r),{instanceId:e}},fromExtendedKey:t=>{if(!t.base58key)throw new Error("Missing base58key parameter");const e=He(),r=Ne.fromExtendedKey(t.base58key,t.versions);return Ce.set(e,r),{instanceId:e}},fromJSON:t=>{if(!t.json)throw new Error("Missing json parameter");const e=He(),r=Ne.fromJSON(t.json);return Ce.set(e,r),{instanceId:e}},derive:(t,e)=>{if(!e)throw new Error("Missing instanceId parameter");if(!t.path)throw new Error("Missing path parameter");const r=Ce.get(e);if(!r)throw new Error("Instance not found");const n=r.derive(t.path),i=He();return Ce.set(i,n),{instanceId:i}},deriveChild:(t,e)=>{if(!e)throw new Error("Missing instanceId parameter");if(void 0===t.index)throw new Error("Missing index parameter");const r=Ce.get(e);if(!r)throw new Error("Instance not found");const n=r.deriveChild(t.index),i=He();return Ce.set(i,n),{instanceId:i}},sign:(t,e)=>{if(!e)throw new Error("Missing instanceId parameter");if(!t.hash)throw new Error("Missing hash parameter");const r=Ce.get(e);if(!r)throw new Error("Instance not found");const n=r.sign(new Uint8Array(t.hash));return{signature:Array.from(n)}},verify:(t,e)=>{if(!e)throw new Error("Missing instanceId parameter");if(!t.hash||!t.signature)throw new Error("Missing hash or signature parameter");const r=Ce.get(e);if(!r)throw new Error("Instance not found");return{isValid:r.verify(new Uint8Array(t.hash),new Uint8Array(t.signature))}},wipePrivateData:(t,e)=>{if(!e)throw new Error("Missing instanceId parameter");const r=Ce.get(e);if(!r)throw new Error("Instance not found");return r.wipePrivateData(),{}},toJSON:(t,e)=>{if(!e)throw new Error("Missing instanceId parameter");const r=Ce.get(e);if(!r)throw new Error("Instance not found");return r.toJSON()},getProperty:(t,e)=>{if(!e)throw new Error("Missing instanceId parameter");if(!t.property)throw new Error("Missing property parameter");const r=Ce.get(e);if(!r)throw new Error("Instance not found");if(!(t.property in r))throw new Error("Unknown property: ".concat(String(t.property)));return(n=r[t.property])instanceof Uint8Array?Array.from(n):n;var n},dispose:(t,e)=>{if(!e)throw new Error("Missing instanceId parameter");if(!Ce.has(e))throw new Error("Instance not found");return Ce.delete(e),{}}};window.addEventListener("message",function(t){const e=JSON.parse(t.data);if("hdkey_operation"!==e.type)return;const r={id:e.id,success:!1};try{const t=Le[e.operation];if(!t)throw new Error("Unknown operation: ".concat(e.operation));const n=t(e.params,e.instanceId);r.success=!0,r.result=n}catch(t){r.error=t instanceof Error?t.message:"Unknown error"}window.ReactNativeWebView&&window.ReactNativeWebView.postMessage(JSON.stringify(r))})})();</script>
</body>
</html>